<!DOCTYPE html>
<meta charset="utf-8" />
<style>
  .background {
    fill: black;
    pointer-events: all;
  }

  #states {
    fill: grey;
  }

  #state-borders {
    fill: none;
    stroke: black;
    /* stroke-width: 1.5px; */
    stroke-linejoin: round;
    stroke-linecap: round;
    pointer-events: none;
  }

  /* >>> for clock >>> */

  .wrapper {
    width: 100%;
    padding: 40px;
    box-sizing: border-box;
    /* background-color: black; */
    background-color: rgba(0, 0, 0, 0.5);
    display: flex;
    align-items: center;
    flex-direction: column;
  }

  .clock {
    background-color: rgba(255, 243, 217, 0.2);
    border: 3px solid #fff;
    width: 400px;
    height: 400px;
    position: relative;
    border-radius: 50%;
  }

  .clock::after {
    width: 16px;
    height: 16px;
    background: #fff;
    content: "";

    position: absolute;
    top: calc(50% - 8px);
    left: calc(50% - 8px);
    border-radius: 50%;
  }

  .line {
    position: absolute;
    transform-origin: bottom;
  }

  .hour {
    width: 8px;
    height: 140px;
    background: #fff;
    top: calc(50% - 140px);
    left: calc(50% - 4px);
  }

  .min {
    width: 4px;
    height: 180px;
    background: #fff;
    top: calc(50% - 180px);
    left: calc(50% - 2px);
  }

  .scale {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .scale > div {
    position: absolute;
    top: 0;
    left: calc(50% - 2px);
    width: 4px;
    height: 50%;
    transform-origin: bottom;
  }

  .scale > div::after {
    position: absolute;
    top: 0;
    content: "";
    width: 4px;
    height: 12px;
    background-color: #fff;
  }

  #setTime {
    font-size: 30px;
    color: #fff;
  }
  /* <<< for clock <<< */
</style>
<link rel="stylesheet" href="sidebar.css" />
<body bgcolor="black">
  <!-- >>> for sidebar >>> -->
  <input type="checkbox" class="openSidebarMenu" id="openSidebarMenu" />
  <label for="openSidebarMenu" class="sidebarIconToggle">
    <div class="spinner diagonal part-1"></div>
    <div class="spinner horizontal"></div>
    <div class="spinner diagonal part-2"></div>
  </label>
  <div id="sidebarMenu">
    <!-- <ul class="sidebarMenuInner">
      <li>Jelena Jovanovic <span>Web Developer</span></li>
      <li><a href="https://vanila.io" target="_blank">Company</a></li>
      <li>
        <a href="https://instagram.com/plavookac" target="_blank">Instagram</a>
      </li>
      <li>
        <a href="https://twitter.com/plavookac" target="_blank">Twitter</a>
      </li>
      <li>
        <a
          href="https://www.youtube.com/channel/UCDfZM0IK6RBgud8HYGFXAJg"
          target="_blank"
          >YouTube</a
        >
      </li>
      <li>
        <a href="https://www.linkedin.com/in/plavookac/" target="_blank"
          >Linkedin</a
        >
      </li>
    </ul> -->

    <!-- >>> for search >>> -->
    <div class="wrapper">
      <input type="text" id="inputEkiname" />
      <br />
      <button id="searchButton" onclick="ekiSearch()">Search</button>
    </div>
    <!-- <<< for search <<< -->
    <!-- >>> for clock >>> -->
    <div class="wrapper">
      <div class="clock" id="clock">
        <div class="scale" id="scale"></div>
        <div class="hour line"></div>
        <div class="min line"></div>
      </div>
      <div id="setTime"></div>
    </div>
    <script src="./clock.js"></script>
    <!-- <<< for clock <<< -->
  </div>
  <!-- <div id="center" class="main center">
    <div class="mainInner">
      <div>PURE CSS SIDEBAR TOGGLE MENU</div>
    </div>
    <div class="mainInner">
      <div>PURE CSS SIDEBAR TOGGLE MENU</div>
    </div>
    <div class="mainInner">
      <div>PURE CSS SIDEBAR TOGGLE MENU</div>
    </div>
  </div> -->
  <!-- <<< for sidebar <<< -->
  <script src="./d3.js" charset="utf-8"></script>
  <script src="//d3js.org/topojson.v1.min.js"></script>
  <script src="./search.js"></script>
  <script src="https://d3js.org/d3-hexbin.v0.2.min.js"></script>
  <script>
    var w = window,
      d = document,
      e = d.documentElement,
      BODY = d.getElementsByTagName("body")[0];
    var width = w.innerWidth || e.clientWidth || BODY.clientWidth;
    var height = w.innerHeight || e.clientHeight || BODY.clientHeight;

    var userSetHour = 0;
    var userSetTime = 30;
    var ekiNameToEkiData = {};

    d3.select(window).on("resize", resizing);

    var projection = d3
      .geoMercator()
      .scale(60000)
      .center([139.463191, 35.710335])
      .translate([width / 2, height / 2]);

    var path = d3.geoPath().projection(projection);

    var zoom = d3
      .zoom()
      .scaleExtent([1, 200])
      .on("zoom", function (event) {
        // g.attr("transform", event.transform);
        g.selectAll("path").attr("transform", event.transform);
        g.selectAll("circle")
          .attr("transform", event.transform)
          .attr("r", function (d) {
            return (1.2 * Math.sqrt(d.noriire)) / Math.cbrt(event.transform.k);
          })
          .attr("stroke-width", 0.4 / Math.cbrt(event.transform.k));
        g.selectAll("line")
          .attr("transform", event.transform)
          .attr("stroke-width", 2 / Math.cbrt(event.transform.k));
        g.selectAll("#state-borders").attr(
          "stroke-width",
          1.5 / Math.cbrt(event.transform.k)
        );
      });

    var svg = d3
      .select("body")
      .append("svg")
      .attr("width", width)
      .attr("height", height)
      .attr("x", 0)
      .attr("y", 0);

    var g = svg.append("g").call(zoom);

    g.append("rect")
      .attr("class", "background")
      .attr("width", width)
      .attr("height", height);
    // .attr("stroke", "lightgrey")
    // .attr("stroke-width", 20);
    showMap();

    d3.csv("data.csv").then(function (data) {
      data.forEach(function (d) {
        ekiNameToEkiData[d.name] = d;
      });
      setTimeout(() => {
        showCircle(data);
      }, 250);
    });
    d3.csv("joinWithIdoKeido.csv").then(function (data) {
      setTimeout(() => {
        showline(data);
      }, 120);
    });

    function showMap() {
      d3.json("./tokyo.topojson").then(function (tk) {
        var tokyo = topojson.feature(tk, tk.objects.tokyo);
        g.append("g")
          .attr("id", "states")
          .selectAll("path")
          .data(tokyo.features)
          .enter()
          .append("path")
          .attr("d", path);
        // .on("click", clicked);

        g.append("path")
          .datum(
            topojson.mesh(tk, tk.objects.tokyo, function (a, b) {
              return a !== b;
            })
          )
          .attr("id", "state-borders")
          .attr("stroke-width", 1.5)
          .attr("d", path);
      });
    }

    function showline(data) {
      function position(p) {
        p.attr("x1", function (d) {
          return projection([d.fromIdo, d.fromKeido])[0];
        });
        p.attr("y1", function (d) {
          return projection([d.fromIdo, d.fromKeido])[1];
        });
        p.attr("x2", function (d) {
          return projection([d.toIdo, d.toKeido])[0];
        });
        p.attr("y2", function (d) {
          return projection([d.toIdo, d.toKeido])[1];
        });
        p.attr("stroke", function (d) {
          return "rgb(" + d.r + "," + d.g + "," + d.b + ")";
        });
        p.attr("class", function (d) {
          return (
            "s" + d.fromID + "_" + d.toID + " " + "s" + d.toID + "_" + d.fromID
          );
        });
      }
      var links = g
        .selectAll("line")
        .data(data)
        .enter()
        .append("line")
        .attr("stroke-width", 2)
        .attr("class", function (d) {
          return (
            "s" + d.fromID + "_" + d.toID + " " + "s" + d.toID + "_" + d.fromID
          );
        })
        .call(position);

      links.append("title").text(function (d) {
        // console.log(d);
        return d.routeName;
      });
    }

    // function showhexagon(data){
    //   function position(p) {
    //     p.attr("cx", function (d) {
    //       return projection([d.ido, d.keido])[0];
    //     });
    //     p.attr("cy", function (d) {
    //       return projection([d.ido, d.keido])[1];
    //     });
    //     p.attr("r", function (d) {
    //       return 1.2 * Math.sqrt(d.noriire);
    //     });
    //     p.attr("stroke-width", 0.4);
    //   }

    //   var circle = g
    //     .selectAll("circle")
    //     .data(data)
    //     .enter()
    //     .append("circle")
    //     .sort(order)
    //     .attr("class", "circle")
    //     .attr("fill", "white")
    //     .attr("fill-opacity", 0.2)
    //     .attr("stroke", "white")
    //     .call(position);

    //   circle.on("click", function (event, d) {
    //     d3.selectAll("line").attr("opacity", 0);
    //     console.log(d);
    //     within_T_min(d.GroupID, 60);
    //     setTimeout(() => {
    //       while (stationQueue.length) {
    //         var rinsetsu_stations = stationQueue.shift();
    //         g.select(
    //           ".s" + rinsetsu_stations[0] + "_" + rinsetsu_stations[1]
    //         ).attr("opacity", 1);
    //       }
    //     }, 1000);
    //   });
    //   circle.append("title").text(function (d) {
    //     // console.log(d);
    //     return d.name;
    //   });

    //   // circle.on("mouseover", onMouseover).on("mouseout", onMouseout);
    //   function order(a, b) {
    //     return b.noriire - a.noriire;
    //   }
    // }

    function showCircle(data) {
      function position(p) {
        p.attr("cx", function (d) {
          return projection([d.ido, d.keido])[0];
        });
        p.attr("cy", function (d) {
          return projection([d.ido, d.keido])[1];
        });
        p.attr("r", function (d) {
          return 1.2 * Math.sqrt(d.noriire);
        });
        p.attr("stroke-width", 1);
        p.attr("id", function (d) {
          return d.name + d.GroupID;
        });
      }

      var circle = g
        .selectAll("circle")
        .data(data)
        .enter()
        .append("circle")
        .sort(order)
        .attr("class", "circle")
        .attr("fill", "white")
        .attr("fill-opacity", 0.2)
        .attr("stroke", "white")
        .call(position);

      circle.on("click", function (event, d) {
        d3.selectAll("line").attr("opacity", 0);
        console.log(d);
        within_T_min(d.GroupID, userSetHour * 60 + userSetTime);
        setTimeout(() => {
          while (stationQueue.length) {
            var rinsetsu_stations = stationQueue.shift();
            g.select(
              ".s" + rinsetsu_stations[0] + "_" + rinsetsu_stations[1]
            ).attr("opacity", 1);
          }
        }, 1000);
      });
      circle.append("title").text(function (d) {
        // console.log(d);
        return d.name;
      });

      // circle.on("mouseover", onMouseover).on("mouseout", onMouseout);
      function order(a, b) {
        return b.noriire - a.noriire;
      }
    }

    function resizing() {
      w = window;
      e = d.documentElement;
      BODY = d.getElementsByTagName("body")[0];
      width = w.innerWidth || e.clientWidth || BODY.clientWidth;
      height = w.innerHeight || e.clientHeight || BODY.clientHeight;
      svg.attr("width", width).attr("height", height);
      svg.selectAll(".background").attr("width", width).attr("height", height);
    }

    function openGoogleMap(d) {
      window.open(
        "https://www.google.co.jp/maps/search/%E3%83%AC%E3%82%B9%E3%83%88%E3%83%A9%E3%83%B3+" +
          d.name
      );
    }

    function ekiSearch() {
      var inputName = document.getElementById("inputEkiname").value;
      if (ekiNameToEkiData[inputName] == undefined) {
        console.log("Not Found");
        alert(inputName + "駅が見つかりません");
        return;
      }
      inputEkidata = ekiNameToEkiData[inputName];

      console.log("#" + inputEkidata.name + inputEkidata.GroupID);
      g.select("#" + inputEkidata.name + inputEkidata.GroupID)
        .transition()
        .duration(1500)
        .ease(d3.easeSin, d3.easeSinInOut)
        .attr("r", function (d) {
          console.log(d);
          return 1.2 * Math.sqrt(d.noriire) * 20;
        })
        .transition()
        .ease(d3.easeSin, d3.easeSinInOut)
        .attr("r", function (d) {
          return 1.2 * Math.sqrt(d.noriire);
        });
    }
  </script>
</body>
