<html lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>search branch:mitarai</title>
<script type="text/javascript" src="./d3.js"></script>
<style type="text/css">
</style>
</head>
<body>

<script type="text/javascript">

within_T_min(1130101, 100);
//meet_up([1130101, 1130212, 2400605, 1132005], 4, 100);

function within_T_min(startGroupID, T){
    var Adj_list = {}   //隣接リスト　keyはgroupe ID
    var groupInfo = {}  //グループIDでそのグループ内の駅情報を検索するための辞書 keyはgroupe ID
    var time = {}       //その駅グループに到達するまでの所要時間    keyはgroupe ID
    var previousNode = {}   //ひとつ前の[駅グループ, routename]を格納　keyはgroupe ID
    var previousRouteID = {}    //その駅グループに来るのに使用した路線ＩＤ　keyはgroupe ID

    var queue = new pairing_heap(); //最大ヒープ

    var ARAKAWASEN = 0.8;   //所要時間0分の駅間の所要時間
    var changeTrains_time = 5;  //乗り換え時間
    var stopTime = 0.7;         //停車時間
    new Promise((resolve) => {
        Make_Adj_List();
        resolve();
    }).then(() => {
        setTimeout(() => {
            dijkstra();
        }, 100);
    });

    //return //到達可能駅のリスト
    function Make_Adj_List(){
        var groupInfo_flag = {}

        d3.csv("../importantData/join.csv").then(function(data){
            data.forEach(function(d){
                var time_tmp
                if (d.time == 0){
                    time_tmp = ARAKAWASEN;  //d.time=0のときの例外処理
                }else{
                    time_tmp = d.time;
                }
                if (Adj_list[d.fromGroupID] == undefined){
                    Adj_list[d.fromGroupID] = [[d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.fromGroupID] = [[d.fromID, d.fromName, d.routeID, d.routeName]];
                    groupInfo_flag[d.fromGroupID] = [d.fromID];
                    time[d.fromGroupID] = T + 100;
                    previousNode[d.fromGroupID] = [];
                    previousRouteID[d.fromGroupID] = [];
                }
                else{
                    Adj_list[d.fromGroupID].push([d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.fromGroupID].indexOf(d.fromID) == -1){
                        groupInfo[d.fromGroupID].push([d.fromID, d.fromName, d.routeID, d.routeName]);
                        groupInfo_flag[d.fromGroupID].push(d.fromID);
                    }
                }
                if (Adj_list[d.toGroupID] == undefined){
                    Adj_list[d.toGroupID] = [[d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.toGroupID] = [[d.toID, d.toName, d.routeID, d.routeName]];
                    groupInfo_flag[d.toGroupID] = [d.toID];
                    time[d.toGroupID] = T + 100;
                    previousNode[d.toGroupID] = [];
                    previousRouteID[d.toGroupID] = [];
                }
                else{
                    Adj_list[d.toGroupID].push([d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.toGroupID].indexOf(d.toID) == -1){
                        groupInfo[d.toGroupID].push([d.toID, d.toName, d.routeID, d.routeName]);
                        groupInfo_flag[d.toGroupID].push(d.toID);
                    }
                } 
            });
        });
    }
    function dijkstra(){
        time[startGroupID] = 0; //スタート地点の時間は0
        previousNode[startGroupID] = "start";

        queue.enqueue(-time[startGroupID], startGroupID);   //最大ヒープなのでtimeにマイナス付ける

        while(queue.size() != 0){
            var currentGroupID = queue.dequeue();
            for(var i = 0; i < Adj_list[currentGroupID].length; i++){
                var nextGroupID = Adj_list[currentGroupID][i][0];
                var nextRouteID = Adj_list[currentGroupID][i][3];
                var dt = parseFloat(Adj_list[currentGroupID][i][5]);  //次の駅までの所要時間
                var current_node_time = parseFloat(time[currentGroupID]);
                var next_node_time = parseFloat(time[nextGroupID]);

                //乗り換え判定
                if (previousRouteID[currentGroupID].indexOf(nextRouteID) == -1 && startGroupID != currentGroupID){
                    changeTrains_flag = parseInt(1);
                }else{
                    changeTrains_flag = parseInt(0);
                }
                if( (next_node_time >= current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag)) && (current_node_time + dt + (changeTrains_time*changeTrains_flag) < T)){
                    var nextRouteName = Adj_list[currentGroupID][i][4]
                    time[nextGroupID] = current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag);
                    previousNode[nextGroupID].push([currentGroupID, nextRouteName]);
                    previousRouteID[nextGroupID].push(nextRouteID)
                    queue.enqueue(-time[nextGroupID], nextGroupID);
                }
            }

        }
    }
}

function meet_up(startGroupID, N, T){
    var Adj_list = {};
    var groupInfo = {};
    var numOfVisitors = {};

    //以下の変数は人数分準備
    var time = Array(N);
    var previousNode = Array(N);
    var previousRouteID = Array(N);
    var visited_flag = Array(N);    //訪問済みならtrue 未訪問はfalse

    for(var i = 0; i < N; i++){
        time[i] = {};
        previousNode[i] = {};
        previousRouteID[i] = {};
        visited_flag[i] = {};
    }

    var queue = new pairing_heap();

    var ARAKAWASEN = 0.8;
    var changeTrains_time = 5;
    var stopTime = 0.7;
    new Promise((resolve) => {
        Make_Adj_List();
        resolve();
    }).then(() => {
        setTimeout(() => {
            dijkstra_meetup();
        }, 100);
    });

    //return //到達可能駅のリスト

    function Make_Adj_List(){
        var groupInfo_flag = {};

        d3.csv("../importantData/join.csv").then(function(data){
            data.forEach(function(d){
                var time_tmp
                if (d.time == 0){
                    time_tmp = ARAKAWASEN;
                }else{
                    time_tmp = d.time;
                }
                if (Adj_list[d.fromGroupID] == undefined){
                    Adj_list[d.fromGroupID] = [[d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.fromGroupID] = [[d.fromID, d.fromName, d.routeID, d.routeName]];
                    groupInfo_flag[d.fromGroupID] = [d.fromID];
                    numOfVisitors[d.fromGroupID] = 0;
                    for(var i = 0; i < N; i++){
                        time[i][d.fromGroupID] = T + 100;
                        previousNode[i][d.fromGroupID] = [];
                        previousRouteID[i][d.fromGroupID] = [];
                        visited_flag[i][d.fromGroupID] = false;
                    }
                }
                else{
                    Adj_list[d.fromGroupID].push([d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.fromGroupID].indexOf(d.fromID) == -1){
                        groupInfo[d.fromGroupID].push([d.fromID, d.fromName, d.routeID, d.routeName]);
                        groupInfo_flag[d.fromGroupID].push(d.fromID);
                    }
                }
                if (Adj_list[d.toGroupID] == undefined){
                    Adj_list[d.toGroupID] = [[d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.toGroupID] = [[d.toID, d.toName, d.routeID, d.routeName]];
                    groupInfo_flag[d.toGroupID] = [d.toID];
                    numOfVisitors[d.toGroupID] = 0;
                    for(var i = 0; i < N; i++){
                        time[i][d.toGroupID] = T + 100;
                        previousNode[i][d.toGroupID] = [];
                        previousRouteID[i][d.toGroupID] = [];
                        visited_flag[i][d.toGroupID] = false;
                    }
                }
                else{
                    Adj_list[d.toGroupID].push([d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.toGroupID].indexOf(d.toID) == -1){
                        groupInfo[d.toGroupID].push([d.toID, d.toName, d.routeID, d.routeName]);
                        groupInfo_flag[d.toGroupID].push(d.toID);
                    }
                } 
            });
        });
    }
    function dijkstra_meetup(){
        for(var i = 0; i < N; i++){
            time[i][startGroupID[i]] = 0;
            previousNode[i][startGroupID[i]] = "start";
            queue.enqueue(-time[i][startGroupID[i]], [i, startGroupID[i]]);
        }

        while(queue.size() != 0){
            var dequeued_item = queue.dequeue();
            var i = dequeued_item[0]; //i is personal_id
            var currentGroupID = dequeued_item[1];

            if (visited_flag[i][currentGroupID] == false){
                //iさんが未訪問なら訪問したことを記録し
                //訪問人数を +1
                visited_flag[i][currentGroupID] = true;
                numOfVisitors[currentGroupID] += parseInt(1);
                if (numOfVisitors[currentGroupID] == N){
                    //全員集合してたら
                    console.log(groupInfo[currentGroupID]);
                    break;
                }
                for(var j = 0; j < Adj_list[currentGroupID].length; j++){
                    var nextGroupID = Adj_list[currentGroupID][j][0];
                    var nextRouteID = Adj_list[currentGroupID][j][3];
                    var dt = parseFloat(Adj_list[currentGroupID][j][5]);
                    var current_node_time = parseFloat(time[i][currentGroupID]);
                    var next_node_time = parseFloat(time[i][nextGroupID]);


                    if (previousRouteID[i][currentGroupID].indexOf(nextRouteID) == -1 && startGroupID.indexOf(currentGroupID) == -1){
                        changeTrains_flag = parseInt(1);
                    }else{
                        changeTrains_flag = parseInt(0);
                    }
                    if( (next_node_time >= current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag)) && (current_node_time + dt + (changeTrains_time*changeTrains_flag) < T)){
                        var nextRouteName = Adj_list[currentGroupID][j][4]
                        time[i][nextGroupID] = current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag);
                        previousNode[i][nextGroupID].push([currentGroupID, nextRouteName]);
                        previousRouteID[i][nextGroupID].push(nextRouteID)
                        queue.enqueue(-time[i][nextGroupID], [i, nextGroupID]);
                    }
                }
            }
        }
    }
}
// https://qiita.com/330k/items/daa144d82b000c72f774
function pairing_heap(){
    "use strict";
    var _root = null;
    var _size = 0;
    var _merge = function (i, j){
        var ret = null;

        if(i === null) return j;
        if(j === null) return i;

        if(i.p < j.p){
            ret = i;
            i = j;
            j = ret;
        }
        j.next = i.head;
        i.head = j;

        return i;
    };
    var _mergeList = function (s){
        var n = null;
        var a = null;
        var b = null;
        var j = null;

        while(s !== null){
            a = s;
            b = null;
            s = s.next;
            a.next = null;
            if(s !== null){
                b = s;
                s = s.next;
                b.next = null;
            }
            a = _merge(a, b);
            a.next = n;
            n = a;
        }
        while(n !== null){
            j = n;
            n = n.next;
            s = _merge(j, s);
        }
        return s;
    };

    var enqueue = function(priority, value){
        _root = _merge(_root, {
            p: priority,
            v: value,
            next: null,
            head: null
        });
        _size = _size + 1;
    };
    var dequeue = function(){
        var result = null;

        if(_size){
            result = _root.v;
            _root = _mergeList(_root.head);
            _size = _size - 1;

            return result;
        }else{
            return (void 0);
        }
    };
    var top = function(){
        return _root.v;
    };
    var size = function(){
        return _size;
    };

    return {
        name: 'Pairing Heap',
        enqueue: enqueue,
        dequeue: dequeue,
        top: top,
        size: size
    };
}

</script>
</body></html>
