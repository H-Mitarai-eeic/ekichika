<html lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>D3 Test</title>
<script type="text/javascript" src="./d3.js"></script>
<style type="text/css">
</style>
</head>
<body>

<script type="text/javascript">

within_T_min(1130101, 10);

function within_T_min(startGroupID, T){
    var Adj_list = {}
    var groupInfo = {}
    var time = {}
    var previousNode = {}
    var previousRouteID = {}
    var groupInfo = {}
    var groupInfo_flag = {}

    var queue = new pairing_heap();

    var ARAKAWASEN = 0.8;
    var changeTrains_time = 5;
    new Promise((resolve) => {
        Make_Adj_List();
        resolve();
    }).then(() => {
        setTimeout(() => {
            dijkstra();
        }, 1000);
    });

    //return //到達可能駅のリスト
    function Make_Adj_List(){
        d3.csv("../importantData/join.csv").then(function(data){
            data.forEach(function(d){
                var time_tmp
                if (d.time == 0){
                    time_tmp = ARAKAWASEN;
                }else{
                    time_tmp = d.time;
                }
                if (Adj_list[d.fromGroupID] == undefined){
                    Adj_list[d.fromGroupID] = [[d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.fromGroupID] = [[d.fromID, d.fromName, d.routeID, d.routeName]];
                    groupInfo_flag[d.fromGroupID] = [d.fromID];
                    time[d.fromGroupID] = T + 100;
                    previousNode[d.fromGroupID] = [];
                    previousRouteID[d.fromGroupID] = [];
                }
                else{
                    Adj_list[d.fromGroupID].push([d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.fromGroupID].indexOf(d.fromID) == -1){
                        groupInfo[d.fromGroupID].push([d.fromID, d.fromName, d.routeID, d.routeName]);
                        groupInfo_flag[d.fromGroupID].push(d.fromID);
                    }
                }
                if (Adj_list[d.toGroupID] == undefined){
                    Adj_list[d.toGroupID] = [[d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.toGroupID] = [[d.toID, d.toName, d.routeID, d.routeName]];
                    groupInfo_flag[d.toGroupID] = [d.toID];
                    time[d.toGroupID] = T + 100;
                    previousNode[d.toGroupID] = [];
                    previousRouteID[d.toGroupID] = [];
                }
                else{
                    Adj_list[d.toGroupID].push([d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.toGroupID].indexOf(d.toID) == -1){
                        groupInfo[d.toGroupID].push([d.toID, d.toName, d.routeID, d.routeName]);
                        groupInfo_flag[d.toGroupID].push(d.toID);
                    }
                } 
                //console.log(Adj_list);
            });
            //console.log("1")
            //console.log(groupInfo);
        });
    }
    function dijkstra(){
        var stopTime = 0.5;
        time[startGroupID] = 0;
        //console.log("2");
        //console.log(Adj_list);
        previousNode[startGroupID] = "start";

        queue.enqueue(-time[startGroupID], startGroupID);

        while(queue.size() != 0){
            var currentGroupID = queue.dequeue();
            for(var i = 0; i < Adj_list[currentGroupID].length; i++){
                var nextGroupID = Adj_list[currentGroupID][i][0];
                var nextRouteID = Adj_list[currentGroupID][i][3];
                var dt = parseInt(Adj_list[currentGroupID][i][5]);
                var current_node_time = parseInt(time[currentGroupID]);
                var next_node_time = parseInt(time[nextGroupID]);


                if (previousRouteID[currentGroupID].indexOf(nextRouteID) == -1 && startGroupID != currentGroupID){
                    changeTrains_flag = parseInt(1);
                }else{
                    changeTrains_flag = parseInt(0);
                }
                if( (next_node_time >= current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag)) && (current_node_time + dt + (changeTrains_time*changeTrains_flag) < T)){
                    var nextRouteName = Adj_list[currentGroupID][i][4]
                    time[nextGroupID] = current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag);
                    previousNode[nextGroupID].push([currentGroupID, nextRouteName]);
                    previousRouteID[nextGroupID].push(nextRouteID)
                    queue.enqueue(-time[nextGroupID], nextGroupID);
                    
                    console.log(current_node_time);
                    console.log(groupInfo[currentGroupID]);
                    //console.log(changeTrains_time*changeTrains_flag);
                    //console.log(previousRouteID[currentGroupID]);
                    //console.log(previousRouteID[nextGroupID]);
                    console.log(previousNode[nextGroupID]);
                    console.log(groupInfo[nextGroupID]);
                    console.log(time[nextGroupID]);
                }
            }

        }
    }
}

// https://qiita.com/330k/items/daa144d82b000c72f774
function pairing_heap(){
    "use strict";
    var _root = null;
    var _size = 0;
    var _merge = function (i, j){
        var ret = null;

        if(i === null) return j;
        if(j === null) return i;

        if(i.p < j.p){
            ret = i;
            i = j;
            j = ret;
        }
        j.next = i.head;
        i.head = j;

        return i;
    };
    var _mergeList = function (s){
        var n = null;
        var a = null;
        var b = null;
        var j = null;

        while(s !== null){
            a = s;
            b = null;
            s = s.next;
            a.next = null;
            if(s !== null){
                b = s;
                s = s.next;
                b.next = null;
            }
            a = _merge(a, b);
            a.next = n;
            n = a;
        }
        while(n !== null){
            j = n;
            n = n.next;
            s = _merge(j, s);
        }
        return s;
    };

    var enqueue = function(priority, value){
        _root = _merge(_root, {
            p: priority,
            v: value,
            next: null,
            head: null
        });
        _size = _size + 1;
    };
    var dequeue = function(){
        var result = null;

        if(_size){
            result = _root.v;
            _root = _mergeList(_root.head);
            _size = _size - 1;

            return result;
        }else{
            return (void 0);
        }
    };
    var top = function(){
        return _root.v;
    };
    var size = function(){
        return _size;
    };

    return {
        name: 'Pairing Heap',
        enqueue: enqueue,
        dequeue: dequeue,
        top: top,
        size: size
    };
}

</script>
</body></html>
