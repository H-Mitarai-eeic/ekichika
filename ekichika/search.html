<html lang="en"><head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>D3 Test</title>
<script type="text/javascript" src="./d3.js"></script>
<style type="text/css">
</style>
</head>
<body>

<script type="text/javascript">

within_T_min(1130101, 100);
//meet_up([1130101, 1130102], 2, 100);

function within_T_min(startGroupID, T){
    var Adj_list = {}
    var groupInfo = {}
    var time = {}
    var previousNode = {}
    var previousRouteID = {}
    var groupInfo = {}

    var queue = new pairing_heap();

    var ARAKAWASEN = 0.8;
    var changeTrains_time = 5;
    var stopTime = 0.7;
    new Promise((resolve) => {
        Make_Adj_List();
        resolve();
    }).then(() => {
        setTimeout(() => {
            dijkstra();
        }, 100);
    });

    //return //到達可能駅のリスト
    function Make_Adj_List(){
        var groupInfo_flag = {}

        d3.csv("../importantData/join.csv").then(function(data){
            data.forEach(function(d){
                var time_tmp
                if (d.time == 0){
                    time_tmp = ARAKAWASEN;
                }else{
                    time_tmp = d.time;
                }
                if (Adj_list[d.fromGroupID] == undefined){
                    Adj_list[d.fromGroupID] = [[d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.fromGroupID] = [[d.fromID, d.fromName, d.routeID, d.routeName]];
                    groupInfo_flag[d.fromGroupID] = [d.fromID];
                    time[d.fromGroupID] = T + 100;
                    previousNode[d.fromGroupID] = [];
                    previousRouteID[d.fromGroupID] = [];
                }
                else{
                    Adj_list[d.fromGroupID].push([d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.fromGroupID].indexOf(d.fromID) == -1){
                        groupInfo[d.fromGroupID].push([d.fromID, d.fromName, d.routeID, d.routeName]);
                        groupInfo_flag[d.fromGroupID].push(d.fromID);
                    }
                }
                if (Adj_list[d.toGroupID] == undefined){
                    Adj_list[d.toGroupID] = [[d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.toGroupID] = [[d.toID, d.toName, d.routeID, d.routeName]];
                    groupInfo_flag[d.toGroupID] = [d.toID];
                    time[d.toGroupID] = T + 100;
                    previousNode[d.toGroupID] = [];
                    previousRouteID[d.toGroupID] = [];
                }
                else{
                    Adj_list[d.toGroupID].push([d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.toGroupID].indexOf(d.toID) == -1){
                        groupInfo[d.toGroupID].push([d.toID, d.toName, d.routeID, d.routeName]);
                        groupInfo_flag[d.toGroupID].push(d.toID);
                    }
                } 
                //console.log(Adj_list);
            });
            //console.log("1")
            //console.log(groupInfo);
        });
    }
    function dijkstra(){
        time[startGroupID] = 0;
        //console.log("2");
        //console.log(Adj_list);
        previousNode[startGroupID] = "start";

        queue.enqueue(-time[startGroupID], startGroupID);

        while(queue.size() != 0){
            var currentGroupID = queue.dequeue();
            for(var i = 0; i < Adj_list[currentGroupID].length; i++){
                var nextGroupID = Adj_list[currentGroupID][i][0];
                var nextRouteID = Adj_list[currentGroupID][i][3];
                var dt = parseInt(Adj_list[currentGroupID][i][5]);
                var current_node_time = parseInt(time[currentGroupID]);
                var next_node_time = parseInt(time[nextGroupID]);


                if (previousRouteID[currentGroupID].indexOf(nextRouteID) == -1 && startGroupID != currentGroupID){
                    changeTrains_flag = parseInt(1);
                }else{
                    changeTrains_flag = parseInt(0);
                }
                if( (next_node_time >= current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag)) && (current_node_time + dt + (changeTrains_time*changeTrains_flag) < T)){
                    var nextRouteName = Adj_list[currentGroupID][i][4]
                    time[nextGroupID] = current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag);
                    previousNode[nextGroupID].push([currentGroupID, nextRouteName]);
                    previousRouteID[nextGroupID].push(nextRouteID)
                    queue.enqueue(-time[nextGroupID], nextGroupID);
                    
                    //console.log(current_node_time);
                    //console.log(groupInfo[currentGroupID]);
                    //console.log(changeTrains_time*changeTrains_flag);
                    //console.log(previousRouteID[currentGroupID]);
                    //console.log(previousRouteID[nextGroupID]);
                    //console.log(previousNode[nextGroupID]);
                    //console.log(groupInfo[nextGroupID]);
                    //console.log(time[nextGroupID]);
                }
            }

        }
    }
}

function meet_up(startGroupID, N, T){
    var Adj_list = {};
    var groupInfo = {};
    var groupInfo = {};
    var visit_flag = {};

    var time = Array(N);
    var previousNode = Array(N);
    var previousRouteID = Array(N);
    time.fill({});
    previousNode.fill({});
    previousRouteID.fill({})

    var queue = new pairing_heap();

    var ARAKAWASEN = 0.8;
    var changeTrains_time = 5;
    var stopTime = 0.7;
    new Promise((resolve) => {
        Make_Adj_List();
        resolve();
    }).then(() => {
        setTimeout(() => {
            dijkstra();
        }, 100);
    });

    //return //到達可能駅のリスト

    function Make_Adj_List(){
        var groupInfo_flag = {};

        d3.csv("../importantData/join.csv").then(function(data){
            data.forEach(function(d){
                var time_tmp
                if (d.time == 0){
                    time_tmp = ARAKAWASEN;
                }else{
                    time_tmp = d.time;
                }
                if (Adj_list[d.fromGroupID] == undefined){
                    Adj_list[d.fromGroupID] = [[d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.fromGroupID] = [[d.fromID, d.fromName, d.routeID, d.routeName]];
                    groupInfo_flag[d.fromGroupID] = [d.fromID];
                    for(var i = 0; i < N; i++){
                        time[i][d.fromGroupID] = T + 100;
                        previousNode[i][d.fromGroupID] = [];
                        previousRouteID[i][d.fromGroupID] = [];
                    }
                }
                else{
                    Adj_list[d.fromGroupID].push([d.toGroupID, d.toID, d.toName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.fromGroupID].indexOf(d.fromID) == -1){
                        groupInfo[d.fromGroupID].push([d.fromID, d.fromName, d.routeID, d.routeName]);
                        groupInfo_flag[d.fromGroupID].push(d.fromID);
                    }
                }
                if (Adj_list[d.toGroupID] == undefined){
                    Adj_list[d.toGroupID] = [[d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]];
                    groupInfo[d.toGroupID] = [[d.toID, d.toName, d.routeID, d.routeName]];
                    groupInfo_flag[d.toGroupID] = [d.toID];
                    for(var i = 0; i < N; i++){
                        time[i][d.toGroupID] = T + 100;
                        previousNode[i][d.toGroupID] = [];
                        previousRouteID[i][d.toGroupID] = [];
                    }
                }
                else{
                    Adj_list[d.toGroupID].push([d.fromGroupID, d.fromID, d.fromName, d.routeID, d.routeName, time_tmp]);
                    if (groupInfo_flag[d.toGroupID].indexOf(d.toID) == -1){
                        groupInfo[d.toGroupID].push([d.toID, d.toName, d.routeID, d.routeName]);
                        groupInfo_flag[d.toGroupID].push(d.toID);
                    }
                } 
            });
        });
    }
    function dijkstra_meetup(){
        for(var i = 0; i < N; i++){
            time[i][startGroupID[i]] = 0;
            previousNode[i][startGroupID[i]] = "start";
            queue.enqueue(-time[startGroupID[i]], [i, startGroupID[i]]);
        }

        while(queue.size() != 0){
            var dequeued_item = queue.dequeue();
            var i = dequeued_item[0]; //i is personal_id
            var currentGroupID = dequeued_item[1];
            for(var j = 0; j < Adj_list[currentGroupID].length; j++){
                var nextGroupID = Adj_list[currentGroupID][j][0];
                var nextRouteID = Adj_list[currentGroupID][j][3];
                var dt = parseInt(Adj_list[currentGroupID][j][5]);
                var current_node_time = parseInt(time[i][currentGroupID]);
                var next_node_time = parseInt(time[i][nextGroupID]);


                if (previousRouteID[i][currentGroupID].indexOf(nextRouteID) == -1 && startGroupID.indexOf(currentGroupID) == -1){
                    changeTrains_flag = parseInt(1);
                }else{
                    changeTrains_flag = parseInt(0);
                }
                if( (next_node_time >= current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag)) && (current_node_time + dt + (changeTrains_time*changeTrains_flag) < T)){
                    var nextRouteName = Adj_list[currentGroupID][j][4]
                    time[nextGroupID] = current_node_time + dt + stopTime + (changeTrains_time*changeTrains_flag);
                    previousNode[nextGroupID].push([currentGroupID, nextRouteName]);
                    previousRouteID[nextGroupID].push(nextRouteID)
                    queue.enqueue(-time[nextGroupID], nextGroupID);
                }
            }
        }
    }
}
// https://qiita.com/330k/items/daa144d82b000c72f774
function pairing_heap(){
    "use strict";
    var _root = null;
    var _size = 0;
    var _merge = function (i, j){
        var ret = null;

        if(i === null) return j;
        if(j === null) return i;

        if(i.p < j.p){
            ret = i;
            i = j;
            j = ret;
        }
        j.next = i.head;
        i.head = j;

        return i;
    };
    var _mergeList = function (s){
        var n = null;
        var a = null;
        var b = null;
        var j = null;

        while(s !== null){
            a = s;
            b = null;
            s = s.next;
            a.next = null;
            if(s !== null){
                b = s;
                s = s.next;
                b.next = null;
            }
            a = _merge(a, b);
            a.next = n;
            n = a;
        }
        while(n !== null){
            j = n;
            n = n.next;
            s = _merge(j, s);
        }
        return s;
    };

    var enqueue = function(priority, value){
        _root = _merge(_root, {
            p: priority,
            v: value,
            next: null,
            head: null
        });
        _size = _size + 1;
    };
    var dequeue = function(){
        var result = null;

        if(_size){
            result = _root.v;
            _root = _mergeList(_root.head);
            _size = _size - 1;

            return result;
        }else{
            return (void 0);
        }
    };
    var top = function(){
        return _root.v;
    };
    var size = function(){
        return _size;
    };

    return {
        name: 'Pairing Heap',
        enqueue: enqueue,
        dequeue: dequeue,
        top: top,
        size: size
    };
}

</script>
</body></html>
